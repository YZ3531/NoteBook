# vue

## 介绍

- 它是一个优秀的前端框架
- 通过数据来改变视图,不需要通过传统操作dom元素来改变视图
- 非常适用于SPA项目的开发`SPA:单页面应用,仅有一个html页面`

## 特点

- 响应式数据:`数据驱动视图`
- MVVM双向绑定:`数据变化,视图则变化,反之也是如此`
- 指令:`扩展了html标签的功能`
- 组件化开发:`复用代码`

## 安装方式

1. **本地引入**

   ```js
   <script src="vue.js"></script>
   ```

2. **在线cdn引入**

3. **npm方式引入**

   ```
   npm i vue
   ```

## 常用实例选项概述

* el(`绑定视图`)

  * **作用 **: 绑定实例管理视图
  * **值** : dom对象
  * **注意** : 不可管理html或者body

* data(`数据`)

  * 存放响应式数据的地方
  * 通过`vue.$data`访问原始数据
  * vue实例代理了`data`上所有属性

* methods(`方法`)

  * 是一个对象(`存放方法`)
  * **注意** : 不可重名

* filter(`过滤器`)

  * **场景 **: 对data中数据进行筛选时可用
  * **使用位置** : 插值表达式内部 || v-bind中
  * **注意** : 第一个参数默认是使用位置前面传来的数据,多个过滤器可以串行起来并排使用
  * **分类** : 
    * 全局:所有vue实例都可用
    * 局部:当前vue实例可用

* computed(`计算属性`)

  * **场景 **: 表达式过于复杂,使用计算属性
  * **说明** : 计算属性的值依赖于data中的值
  * **注意** : 必须有返回值,相当于对复杂逻辑的一次封装
  * **同方法区别** : 方法每次都会执行,计算属性有缓存机制,使用一次后,将结果缓存,数据未发生改变,就去缓存中取,使用方式不需写`()`,方法必须使用`()`来进行调用

* watch(`数据监听`)

  * **场景** : 当数据变化,进行响应业务操作,且该操作为异步操作时,计算属性不能再使用,可用监听watch特性
  * **使用** : key(`监控数据名`):value(`函数`)
  * **同计算属性区别** : 计算属性为`同步操作`,必须有`return`,使用回调函数时,可能获取不到值,就已经return了

* components(`组件`)

  * **场景** : 重复的页面结构,数据,逻辑可以抽提为一个组件

  * **特点** 

    * 是一个特殊的vue实例
    * 没有`el`,但是有`template`
    * 有`data`,但是是一个带返回值的函数,`返回值是一个对象`

  * **分类**

    * 全局

      ```js
       Vue.component('组件名',{
          template:``,
           data(){
               return{
                   
               }
           }
       })
      ```

    * 局部

      ```js
      const vm = new Vue({
          components:{
              '组件名':{
                  template:``,
                  data(){
                      return{
                          
                      }
                  }
          }
      })
      ```

  * **嵌套**

    * 可以在new Vue()实例中使用自定义组件
    * 也可以在注册自定义组件时,嵌套另一个自定义组件,也就是父子组件关系
    * 局部组件 : 在谁的组件上注册,就只能在谁的组件模板(template)中使用

  * **组件通信**

    * 父传子
      * 将传递的值绑定在子组件标签上
      * 子组件通过`props`选项来接收
      * 传过去的值是只读的,不可修改
    * 子传父
      * 通过子组件的`$emit`(自定义事件)携带参数
      * 父组件监听此事件,来获取子组件传递的值

* mounted(`渲染事件`)

* created(`渲染事件`)

* derecive(`自定义指令`)

  * 全局 : `Vue实例之前定义全局自定义指令`
    * Vue.directive("focus", {inserted(dom) {dom.focus();}});
  * 局部 : `Vue的选项上定义`
    * directives: {focus: {inserted(dom) {dom.focus();}}}

## ref

- 作用

  - 通过此特性可以获取dom元素

- 使用

  - dom元素设置ref属性

  ```js
  <input type="text" ref="myInput" /> 
  ```

  - 通过$refs.名称来获取dom对象

  ```js
  this.$refs.myInput.focus();
  ```

## 插值表达式(`Mustache`)

- 作用
  - 将绑定的数据实时显示出来(响应式数据)
- 格式
  - 通过`{{数据名}}`包裹的形式
- 注意
  - 内部中支持JavaScript表达式
  - 每个绑定都只能包含单个表达式
  - 不支持语句
  - 不支持流控制(`可用三元表达式`)
  - 里面只能使用内置全局变量,如:Data(),Math()

## 指令(`Directives`)

- 介绍
  - 格式 : 是带有v-前缀的特殊特性
  - 作用 : 扩展html的功能,指令的职责是当表达式的值改变时,将其产生的连带影响,响应式的作用于DOM
  - 位置 : 起始标签
  - 语法 : v-指令="表达式" ||v-指令="'字符串'"

- 系统指令
  - v-text : v-text更新整个标签中的内容
  - v-html : 可以渲染内容中的html标签
  - v-if : 后面表达式返回布尔值决定是否隐藏(`更高的切换开销,运行时条件很少改变推荐使用`)
  - v-show : 后面表达式返回布尔值决定是否隐藏(`更高的初始渲染开销,频繁切换隐藏推荐`)
  - v-on : 给元素绑定事件
    - 格式 : v-on:事件名.修饰符="方法名"
    - 简写 : @事件名 = "方法名"
  - v-for :  循环遍历数组或对象,生成dom元素
    - 参数(item,index,key)
      - item : 当前项
      - index : 索引
      - key : `对象可用`键名
  - v-bind : 绑定标签上的属性
    - 场景 : 当标签上的属性是变量/动态/需要改变的
    - 格式
      - v-bind : 属性名 = "变量名" 
      - :属性名 = "变量名" `语法糖`
    - 绑定class
      - 对象语法 `:class = "{class名称:布尔值}"`
      - 数组语法`:class = "[class变量1,class变量2...]"`
    - 绑定style
      - 对象语法`:style = "{css属性名 : 变量}"`
      - 数组语法`:style = "[对象1,对象2...]"`
  - v-model : 表单元素的绑定 input/checkout/textarea
    - 特点 : 双向数据绑定,它会`忽略`所有表单的value,checked,selected特性的初始值而总是将实例的数据作为数据来源,`应该在data选项中声明初始值`
    - 语法 : `v-model = "变量"`
    - 原理 : `v-on + v-bind`,当表单值改变,触发事件,重新赋值给数据,数据改变,刷新视图,做到数据双向绑定
  - v-cloak :  解决页面闪烁问题,在实例视图上引用 v-cloak
  - v-once : 使得所在元素只渲染一次,静态化数据,`不建议使用在顶级div上,会造成响应式数据的失效`

## 发送网络请求

1. **vue-resource**
   - vue.js的插件,已经不维护,不推荐使用
2. **axios**
   - 不是vue的插件,可在任何地方使用,推荐
   - 可在浏览器端,node.js中使用的发http请求的库,支持promise,不支持jsonp

## axios

- **优点**`
  - `支持浏览器和node.js,`
  - `支持promise`
  - `能拦截请求和响应`
  - `能转换请求和响应数据`
  - `能取消请求`
  - `自动转换JSON数据`
  - `浏览器端支持防止CSRF(跨站请求伪造)`
- **使用**

```js
// 方式一
axios.类型(地址)
    .then(成功回调函数)
    .catch(失败回调函数)
// 方式二
axios.({
    url:地址
    method:类型
    data:{携带参数}
})
    .then(成功回调函数)
    .catch(失败回调函数)
```

- **注意**
  - post请求成功,status值为201,其余请求为200

## json-server

- 介绍

  - 快速搭建一个后台的接口服务,供前端调用
  - 是一个命令行工具,可以把json文件变成接口文件
  - 遵循restfull接口规则

- 安装

  ```js
  npm i -g json-server
  ```

- 使用

  ```js
  json-server --watch json文件名
  ```

## RESTFUL(`接口规范`)

- 介绍
  - 用不同请求类型,发送同一个请求标识,所对应的的处理是不同的
- 支持模糊搜索
  -  GET /brands?字段名_like=关键字

## SPA

- **同传统页面区别**
  - 传统页面
    - 每个页面及其内容都需要从服务器一次次请求,网络差的话,体验则会感觉很慢
  - SPA页面
    - 第一次加载会将所有的资源都请求到页面.模块之间切换,不会再请求服务器
- **优点**
  - 用户体验好,前端操作几乎感受不到网络的延迟
  - 完全组件化开发,因为只有一个页面,所以原来属于一个个页面的工作被归类为一个个组件
- **缺点**
  - 首屏加载慢--`解决方案 : 按需加载,不刷新页面,只请求js模块`
  - 不利于SEO--`解决方案 : 服务端渲染(node->自己写路由->express-art-template + res.render())`
  - 开发难度高(框架)相对于传统模式,有一些学习成本和应用成本
- **原理**
  - 需求
    - 实现能够在前端自由切换模块
    - 要能记忆当前切换到模块,并且刷新页面模块依然还在当前视图
    - 实现在前段切换模块时,不能引起页面刷新,否则页面内容会被重置
  - 结论
    - 可以通过页面地址的锚链接来实现SPA
    - hash(锚链接)位于连接地址#之后
    - hash值的改变不会触发页面刷新
    - hash值的url地址的一部分,会存储在页面地址上,我们可以获取到
    - 可以通过事件监听hash值的改变
    - 拿到了hash值,就可以根据不同的hash值进行不同的模块切换

## vue-router

- **介绍**
  - 是Vue.js官方的路由管理器,它和Vue.js的核心深度集成,让构建单页面应用变得易如反掌,它是一个插件
  - 实现根据不同的请求地址,而显示不同的组件
  - 如果要用vue开发项目,前端路由功能必须使用vue-router来实现
- **使用**
  - 1.下载并导入
  - 2.设置html内容
  - 3.创建组件
  - 4.实例化路由对象,配置路由规则
  - 5.vue实例挂载路由
- **动态路由**
  - 场景
    - 页面跳转需要协带参数,会导致页面path不同,而却需要对应一个组件,所需需要用到动态路由
  - 方案
    - 路由规则中增加参数,在path最后增加 :id 这里的id相当于我们给路由加了参数,叫做id
    - 通过<router-link>传参,在路径上传入具体的值(实参)
    - 在组件内部可以使用,this.$route获取当前路由对象,并通过params获取定义的参数id
- **属性赋值**
  - 方式
    - 常规跳转--`<router-link to="/sport">体育</router-link> `
    - 变量--`<router-link :to="path">体育</router-link>`
    - 根据对象name跳转--`<router-link :to="{name:'abcdefg'}">体育</router-link>`
    - 根据对象path跳转--`<router-link :to="{path:'/sport'}">体育</router-link>`
    - 带参数的跳转--`<router-link :to="{name:'abcdefg',params:{a:1}}">体育</router-link>`
  - 注意
    - 如果提供了`path`,`params`会被忽略,上述例子中name并不属于这种情况,你可以`提供路由的name`并`手写完整的参数params`
- **重定向**
  - 场景
    - 当希望某个页面被强制中转时,可采用redirect进行路由重定向设置(拦截谁就在谁的路由表上写redirect)
- **编程式导航**
  - 跳转不同的组件,不仅仅可以用router-link,还可以采用代码行为
  - (Vue实例)this.$router可以拿到当前路由对象的实例
  - 注意 :前面小节获取数据用到的是$route,这里用到的是$router
  - 路由对象的实例方法
    - `push()`相当于往历史记录里面推了一条记录,如果点击返回,会回到上一次的地址
    - `replace()`相当于替换当前的记录,历史记录并没有多,但是地址会变
    - `go()`代表希望是前进还是回退,当数字大于0时,就是前进n(数字)次,小于0时,就是后退n(数字)次
- **设置当前激活路由的样式**
  - 当前路由在导航中是拥有激活class样式的
  - 审查导航元素,可以发现激活样式,设置即可
- **嵌套路由**
  - 如果存在路由嵌套,就需要提供多个视图容器<router-view></router-view>
  - 同时,router-link和router-view都可以添加类名,设置样式
  - `注意`
    - 以/开头的嵌套路径会被当做根路径,这让你充分的使用嵌套而无需设置嵌套的路径
    - 如果一个需要给子路由一个默认的显示,就可以配置一个默认的选型

## Vue中的动画过渡

- **介绍**

  - Vue提供了transtion的封装组件,在以下情形中,可以给任何元素和组件添加进入/离开过渡

- **基本用法**

  - 就是给我们需要动画的标签外面嵌套transition标签,并且设置name属性

  ```js
  <transition name="fade"> 
  
  	<div v-show="isShow" class="box"></div>
  
  </transition>
  ```

- **class6种状态**

  - `v-enter`定义进入过渡的开始状态
  - ` v-enter-active`定义进入过渡生效时的状态
  - ` v-enter-to`2.1.8版本及以上定义进入过渡的结束状态
  - ` v-leave`定义离开过渡的开始状态
  - `  v-leave-active`定义离开过渡生效时的状态
  - `v-leave-to`2.1.8版本及以上定义离开过渡的结束状态

- **注意**

  - v要替换成transition组件的name属性值
  - 先要编写元素的最终展示样式

## vue-cli

- **介绍**

  - 是一个辅助开发工具,可以进行代码编译,样式,语法校验,输出设置,其他...
  - 一个命令行工具,最新版本也支持图形化操作,可快速搭建大型网页应用
  - 本质上是一个npm包,也需要npm去安装下载

- **作用**

  - 可以为开发者提供一个标准的项目开发结构和配置

- **安装**

  ```js
  npm i -g @vue-cli	//全局安装最新版本
  npm install -g @vue-cli-init	//安装桥接工具,将2.0的功能补齐到当前脚手架上
  vue -V	//查看版本 等同 vue --version
  ```

- **2.0创建项目**

  ```js
  vue init webpack-simple 项目名	//webpack-simple为模板名称 固定写法
  cd  项目目录	//切换到项目目录
  npm install		//安装依赖
  npm run dev		//在开发模式下,启动运行项目
  ```

- **3.0创建项目**

  ```js
  vue create 项目名	//创建项目(create为关键字)
  cd 项目目录		//切换到当前目录
  npm run serve	//在开发模式下,启动运行项目
  ```

  3.0创建项目时,有两种模式,一个默认模式,一种选择模式

- **项目目录文件介绍**

  - `.bablelrc`存放babel编译的配置信息
  - `.editorconfig `存放编辑器的配置信息
  - `.gitignore`git忽略文件
  - `index.html`单页应用的html
  - `package.json`用于存放依赖信息及其他项目信息
  - `README.md`项目介绍信息,github上的页面信息
  - `webpack.config.js`webpack工具的配置文件,前端工程化的工具,编译代码,压缩代码,处理代码.其他...
  - `main.js`入口
  - `build.js`出口

- **导入&导出**

  - ` import变量from路径`         引入组件
  - `export default 对象`      导出组件

- **单文件组件及入口分析**

  - 介绍
    - 一个.vue文件就是一个组件
    - 一个组件分为三个部分
      - `template(页面模板)`
      - `scrip(组件逻辑)`
      - `style(组件样式)`
  - 注意
    - vue选项中的`render函数`若存在,则vue构造函数`不会从template选项或通过el选项指定的挂载元素中提取出的html模板编译渲染函数`
    - vue-cli的作用就是让我们把精力放在业务编码上,一切准备的工作交给vue-cli去做

## 生命周期函数

**Vue实例从创建到销毁的过程，就是生命周期。从开始创建，初始化数据，编译模板，挂载Dom->渲染，更新->渲染，销毁等一系列过程，称之为vue的生命周期。**

- **第一阶段**
  - `beforeCreate`（创建前），在实例创建之前执行，数据未加载状态；
  - `created` (创建后)：在实例创建、数据加载后；能初始化数据，DOM渲染之前执行；
- **第二阶段**
  - `beforeMount`（载入前），虚拟 DOM 已创建完成，在数据渲染前最后一次更改数据；
  - `mounted`（载入后），页面、数据渲染完成，真实 DOM 挂载完成；
- **第三阶段**
  - `BeforeUpdate`（更新前），重新渲染之前触发；
  - `Updated`（更新后），数据已经更改完成，DOM 也重新 render 完成，更改数据会陷入死循环；
- **第四阶段**
  - `beforeDestroy`（销毁前），在实例销毁之前调用，实例仍然完全可用。
  - `Destroyed`（销毁后），在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。

## 双向绑定原理

- vue进行实例化的时候,会对data选项中的所有属性进行遍历,并使用`object.defineProperty`转化这些属性为`getter/setter`,vue中每个组件实例都会对应一个`watcher`实例,渲染之前的数据作为依赖,当数据发生了改变就会触发`setter`,就会通知给`watcher`,从而使所有与其关联组件重新渲染.